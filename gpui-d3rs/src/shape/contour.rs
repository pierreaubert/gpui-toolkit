//! Contour rendering for GPUI
//!
//! Provides visualization of contour data generated by the d3-contour module.

use crate::color::D3Color;
use crate::contour::Contour;
use crate::scale::Scale;
use gpui::prelude::*;
use gpui::*;
use std::panic;
use std::sync::Arc;

/// Configuration for contour rendering
#[derive(Clone)]
pub struct ContourConfig {
    /// Stroke width for contour lines
    pub stroke_width: f32,
    /// Whether to fill contours
    pub fill: bool,
    /// Fill opacity (0.0 - 1.0)
    pub fill_opacity: f32,
    /// Stroke opacity (0.0 - 1.0)
    pub stroke_opacity: f32,
    /// Color scale function (maps threshold value 0.0-1.0 to color)
    pub color_scale: Option<Arc<dyn Fn(f64) -> D3Color + Send + Sync>>,
    /// Fixed stroke color (used if color_scale is None)
    pub stroke_color: D3Color,
    /// Fixed fill color (used if color_scale is None)
    pub fill_color: D3Color,
}

impl Default for ContourConfig {
    fn default() -> Self {
        Self {
            stroke_width: 1.5,
            fill: true,
            fill_opacity: 0.3,
            stroke_opacity: 1.0,
            color_scale: None,
            stroke_color: D3Color::from_hex(0x4682b4),
            fill_color: D3Color::from_hex(0x4682b4),
        }
    }
}

impl ContourConfig {
    /// Create a new contour configuration
    pub fn new() -> Self {
        Self::default()
    }

    /// Set stroke width
    pub fn stroke_width(mut self, width: f32) -> Self {
        self.stroke_width = width;
        self
    }

    /// Enable or disable fill
    pub fn fill(mut self, fill: bool) -> Self {
        self.fill = fill;
        self
    }

    /// Set fill opacity
    pub fn fill_opacity(mut self, opacity: f32) -> Self {
        self.fill_opacity = opacity.clamp(0.0, 1.0);
        self
    }

    /// Set stroke opacity
    pub fn stroke_opacity(mut self, opacity: f32) -> Self {
        self.stroke_opacity = opacity.clamp(0.0, 1.0);
        self
    }

    /// Set a color scale function
    pub fn color_scale<F>(mut self, f: F) -> Self
    where
        F: Fn(f64) -> D3Color + Send + Sync + 'static,
    {
        self.color_scale = Some(Arc::new(f));
        self
    }

    /// Set fixed stroke color
    pub fn stroke_color(mut self, color: D3Color) -> Self {
        self.stroke_color = color;
        self
    }

    /// Set fixed fill color
    pub fn fill_color(mut self, color: D3Color) -> Self {
        self.fill_color = color;
        self
    }
}

/// A custom element for rendering contours
pub struct ContourElement<XS, YS> {
    /// The contours to render
    contours: Arc<[Contour]>,
    /// X scale
    x_scale: XS,
    /// Y scale
    y_scale: YS,
    /// Configuration
    config: ContourConfig,
    /// Value range for color normalization
    value_range: (f64, f64),
    /// Element height
    height: Pixels,
}

impl<XS, YS> ContourElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone,
    YS: Scale<f64, f64> + Clone,
{
    /// Create a new contour element
    pub fn new(contours: impl Into<Arc<[Contour]>>, x_scale: XS, y_scale: YS) -> Self {
        let contours = contours.into();

        // Calculate value range from contours
        let value_range = if contours.is_empty() {
            (0.0, 1.0)
        } else {
            let min = contours
                .iter()
                .map(|c| c.value)
                .fold(f64::INFINITY, f64::min);
            let max = contours
                .iter()
                .map(|c| c.value)
                .fold(f64::NEG_INFINITY, f64::max);
            (min, max)
        };

        Self {
            contours,
            x_scale,
            y_scale,
            config: ContourConfig::default(),
            value_range,
            height: px(400.0),
        }
    }

    /// Set the configuration
    pub fn config(mut self, config: ContourConfig) -> Self {
        self.config = config;
        self
    }

    /// Set the value range for color normalization
    pub fn value_range(mut self, min: f64, max: f64) -> Self {
        self.value_range = (min, max);
        self
    }

    /// Set the element height
    pub fn height(mut self, height: Pixels) -> Self {
        self.height = height;
        self
    }

    /// Normalize a value to 0.0-1.0 range
    fn normalize_value(&self, value: f64) -> f64 {
        let (min, max) = self.value_range;
        if (max - min).abs() < 1e-10 {
            0.5
        } else {
            (value - min) / (max - min)
        }
    }

    /// Get color for a contour value
    fn get_color(&self, value: f64) -> D3Color {
        let t = self.normalize_value(value);
        if let Some(ref scale) = self.config.color_scale {
            scale(t)
        } else {
            self.config.stroke_color
        }
    }

    /// Get fill color for a contour value
    fn get_fill_color(&self, value: f64) -> D3Color {
        let t = self.normalize_value(value);
        if let Some(ref scale) = self.config.color_scale {
            scale(t)
        } else {
            self.config.fill_color
        }
    }
}

impl<XS, YS> IntoElement for ContourElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone + 'static,
    YS: Scale<f64, f64> + Clone + 'static,
{
    type Element = Self;

    fn into_element(self) -> Self::Element {
        self
    }
}

impl<XS, YS> Element for ContourElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone + 'static,
    YS: Scale<f64, f64> + Clone + 'static,
{
    type RequestLayoutState = ();
    type PrepaintState = ();

    fn id(&self) -> Option<ElementId> {
        None
    }

    fn source_location(&self) -> Option<&'static panic::Location<'static>> {
        None
    }

    fn request_layout(
        &mut self,
        _id: Option<&GlobalElementId>,
        _inspector_id: Option<&InspectorElementId>,
        window: &mut Window,
        cx: &mut App,
    ) -> (LayoutId, Self::RequestLayoutState) {
        // Use the scale's range for width to ensure alignment with other chart elements
        let (x_range_min, x_range_max) = self.x_scale.range();
        let computed_width = px((x_range_max - x_range_min).abs() as f32);

        let layout_id = window.request_layout(
            Style {
                size: size(computed_width.into(), self.height.into()),
                min_size: size(px(100.0).into(), px(100.0).into()),
                ..Default::default()
            },
            [],
            cx,
        );
        (layout_id, ())
    }

    fn prepaint(
        &mut self,
        _id: Option<&GlobalElementId>,
        _inspector_id: Option<&InspectorElementId>,
        _bounds: Bounds<Pixels>,
        _request_layout: &mut Self::RequestLayoutState,
        _window: &mut Window,
        _cx: &mut App,
    ) -> Self::PrepaintState {
    }

    fn paint(
        &mut self,
        _id: Option<&GlobalElementId>,
        _inspector_id: Option<&InspectorElementId>,
        bounds: Bounds<Pixels>,
        _request_layout: &mut Self::RequestLayoutState,
        _prepaint: &mut Self::PrepaintState,
        window: &mut Window,
        _cx: &mut App,
    ) {
        let origin_x: f32 = bounds.origin.x.into();
        let origin_y: f32 = bounds.origin.y.into();
        let width: f32 = bounds.size.width.into();
        let height: f32 = bounds.size.height.into();

        // Get the range (screen coordinates) for proper normalization
        // Use scale.scale() to properly handle log scales
        let (x_range_min, x_range_max) = self.x_scale.range();
        let (y_range_min, y_range_max) = self.y_scale.range();
        let x_range_span = (x_range_max - x_range_min).abs();
        let y_range_span = (y_range_max - y_range_min).abs();

        // Paint each contour (from lowest to highest value for proper layering)
        for contour in self.contours.iter() {
            let stroke_color = self.get_color(contour.value);
            let fill_color = self.get_fill_color(contour.value);

            for ring in &contour.coordinates {
                if ring.points.len() < 3 {
                    continue;
                }

                // Convert ring points to screen coordinates using the scale
                // This properly handles log scales by using scale.scale()
                // Use actual min/max for proper handling of inverted scales
                let x_range_lo = x_range_min.min(x_range_max);
                let y_range_lo = y_range_min.min(y_range_max);

                let screen_points: Vec<Point<Pixels>> = ring
                    .points
                    .iter()
                    .map(|p| {
                        // Use scale.scale() to transform data coordinates to range coordinates
                        // This properly handles log scales
                        let x_scaled = self.x_scale.scale(p.x);
                        let y_scaled = self.y_scale.scale(p.y);

                        // Normalize to 0-1 based on range
                        // Y scale is already inverted (high values at top=0, low at bottom=height)
                        // so no additional inversion needed here
                        let x_norm = ((x_scaled - x_range_lo) / x_range_span) as f32;
                        let y_norm = ((y_scaled - y_range_lo) / y_range_span) as f32;

                        let screen_x = origin_x + x_norm * width;
                        let screen_y = origin_y + y_norm * height;
                        point(px(screen_x), px(screen_y))
                    })
                    .collect();

                // Check if this ring is closed (first and last point are the same)
                let is_closed = if screen_points.len() >= 2 {
                    let first = &screen_points[0];
                    let last = &screen_points[screen_points.len() - 1];
                    let dx: f32 = (first.x - last.x).into();
                    let dy: f32 = (first.y - last.y).into();
                    dx.abs() < 1.0 && dy.abs() < 1.0
                } else {
                    false
                };

                // Paint fill using PathBuilder (only for closed rings without large jumps)
                if self.config.fill && screen_points.len() >= 3 && is_closed {
                    // Detect if this ring has any large jumps that would cause artifacts
                    // Skip filling rings that cross the boundary
                    let x_jump_threshold = width * 0.15;
                    let y_jump_threshold = height * 0.15;
                    let has_jump = screen_points.windows(2).any(|pair| {
                        let dx: f32 = (pair[1].x - pair[0].x).abs().into();
                        let dy: f32 = (pair[1].y - pair[0].y).abs().into();
                        dx > x_jump_threshold || dy > y_jump_threshold
                    });

                    if !has_jump {
                        let mut builder = PathBuilder::fill();
                        builder.move_to(screen_points[0]);
                        for pt in &screen_points[1..] {
                            builder.line_to(*pt);
                        }
                        // Don't call close() - the path is already closed by the data

                        if let Ok(path) = builder.build() {
                            let mut fill_rgba = fill_color.to_rgba();
                            fill_rgba.a *= self.config.fill_opacity;
                            window.paint_path(path, fill_rgba);
                        }
                    }
                }

                // Paint stroke using PathBuilder
                // For open isolines, we need to draw each segment but NOT connect
                // back to the start. For closed isolines, the data already includes the closing point.
                if self.config.stroke_opacity > 0.0 && self.config.stroke_width > 0.0 {
                    // Detect large jumps that indicate we should NOT draw a line
                    // (e.g., isoline wrapping around the plot boundary)
                    // Check both X and Y separately since log scale can compress one axis
                    // Use a lower threshold (15%) to catch more edge cases
                    let x_jump_threshold = width * 0.15;
                    let y_jump_threshold = height * 0.15;

                    let mut builder = PathBuilder::stroke(px(self.config.stroke_width));

                    // Skip the last point if it's a duplicate of the first (closing point added by marching squares)
                    let points_to_draw = if screen_points.len() >= 2 {
                        let first = &screen_points[0];
                        let last = &screen_points[screen_points.len() - 1];
                        let dx: f32 = (first.x - last.x).abs().into();
                        let dy: f32 = (first.y - last.y).abs().into();
                        // If last point is very close to first (duplicate closing point), skip it
                        if dx < 2.0 && dy < 2.0 {
                            &screen_points[..screen_points.len() - 1]
                        } else {
                            &screen_points[..]
                        }
                    } else {
                        &screen_points[..]
                    };

                    for i in 0..points_to_draw.len() {
                        if i == 0 {
                            builder.move_to(points_to_draw[0]);
                        } else {
                            let prev = &points_to_draw[i - 1];
                            let curr = &points_to_draw[i];
                            let dx: f32 = (curr.x - prev.x).abs().into();
                            let dy: f32 = (curr.y - prev.y).abs().into();

                            // Jump if either axis has a large discontinuity
                            if dx > x_jump_threshold || dy > y_jump_threshold {
                                // Large jump detected - start a new sub-path (lift the pen)
                                builder.move_to(*curr);
                            } else {
                                builder.line_to(*curr);
                            }
                        }
                    }

                    if let Ok(path) = builder.build() {
                        let mut stroke_rgba = stroke_color.to_rgba();
                        stroke_rgba.a *= self.config.stroke_opacity;
                        window.paint_path(path, stroke_rgba);
                    }
                }
            }
        }
    }
}

/// Render contours using scales
///
/// # Example
///
/// ```rust,no_run
/// use d3rs::prelude::*;
/// use d3rs::shape::contour::{render_contour, ContourConfig};
/// use d3rs::contour::ContourGenerator;
///
/// let values = vec![0.0; 16]; // 4x4 grid
/// let generator = ContourGenerator::new(4, 4);
/// let contours = generator.contours(&values, &[0.5]);
///
/// let x_scale = LinearScale::new().domain(0.0, 4.0).range(0.0, 400.0);
/// let y_scale = LinearScale::new().domain(0.0, 4.0).range(0.0, 400.0);
///
/// let config = ContourConfig::new()
///     .stroke_width(2.0)
///     .fill(true)
///     .fill_opacity(0.3);
///
/// // render_contour(contours, &x_scale, &y_scale, &config)
/// ```
pub fn render_contour<XS, YS>(
    contours: impl Into<Arc<[Contour]>>,
    x_scale: &XS,
    y_scale: &YS,
    config: &ContourConfig,
) -> ContourElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone,
    YS: Scale<f64, f64> + Clone,
{
    ContourElement::new(contours, x_scale.clone(), y_scale.clone()).config(config.clone())
}

/// Create a viridis-like color scale for contours
pub fn viridis_color_scale() -> impl Fn(f64) -> D3Color + Send + Sync {
    move |t: f64| {
        let t = t.clamp(0.0, 1.0);
        // Simplified viridis approximation
        let colors = [
            D3Color::from_hex(0x440154), // Dark purple
            D3Color::from_hex(0x482878), // Purple
            D3Color::from_hex(0x3e4a89), // Blue-purple
            D3Color::from_hex(0x31688e), // Blue
            D3Color::from_hex(0x26838f), // Teal
            D3Color::from_hex(0x1f9e89), // Green-teal
            D3Color::from_hex(0x35b779), // Green
            D3Color::from_hex(0x6ece58), // Light green
            D3Color::from_hex(0xb5de2b), // Yellow-green
            D3Color::from_hex(0xfde725), // Yellow
        ];

        let idx = (t * (colors.len() - 1) as f64) as usize;
        let idx = idx.min(colors.len() - 2);
        let local_t = (t * (colors.len() - 1) as f64) - idx as f64;

        colors[idx].interpolate(&colors[idx + 1], local_t as f32)
    }
}

/// Create a heat color scale (blue -> white -> red)
pub fn heat_color_scale() -> impl Fn(f64) -> D3Color + Send + Sync {
    move |t: f64| {
        let t = t.clamp(0.0, 1.0);
        if t < 0.5 {
            // Blue to white
            let local_t = t * 2.0;
            D3Color::from_hex(0x0571b0).interpolate(&D3Color::from_hex(0xf7f7f7), local_t as f32)
        } else {
            // White to red
            let local_t = (t - 0.5) * 2.0;
            D3Color::from_hex(0xf7f7f7).interpolate(&D3Color::from_hex(0xca0020), local_t as f32)
        }
    }
}

/// Create a turbo color scale (Google's improved rainbow colormap)
///
/// Turbo is designed to be perceptually uniform while covering a wide
/// range of hues. It's an improvement over jet/rainbow colormaps.
/// Reference: https://ai.googleblog.com/2019/08/turbo-improved-rainbow-colormap-for.html
pub fn turbo_color_scale() -> impl Fn(f64) -> D3Color + Send + Sync {
    move |t: f64| {
        let t = t.clamp(0.0, 1.0);
        // Turbo colormap keypoints (simplified 16-color approximation)
        let colors = [
            D3Color::from_hex(0x30123b), // Dark blue
            D3Color::from_hex(0x4145ab), // Blue
            D3Color::from_hex(0x4675ed), // Light blue
            D3Color::from_hex(0x39a2fc), // Cyan-blue
            D3Color::from_hex(0x1bd0d5), // Cyan
            D3Color::from_hex(0x24f0a0), // Cyan-green
            D3Color::from_hex(0x5dfc69), // Green
            D3Color::from_hex(0xa4fc3c), // Yellow-green
            D3Color::from_hex(0xd9ec37), // Yellow
            D3Color::from_hex(0xfece2f), // Yellow-orange
            D3Color::from_hex(0xfda629), // Orange
            D3Color::from_hex(0xf67828), // Red-orange
            D3Color::from_hex(0xe74a24), // Red
            D3Color::from_hex(0xcd2220), // Dark red
            D3Color::from_hex(0xa91c1c), // Darker red
            D3Color::from_hex(0x7a0403), // Very dark red
        ];

        let idx = (t * (colors.len() - 1) as f64) as usize;
        let idx = idx.min(colors.len() - 2);
        let local_t = (t * (colors.len() - 1) as f64) - idx as f64;

        colors[idx].interpolate(&colors[idx + 1], local_t as f32)
    }
}

/// Create a magma color scale (perceptually uniform, dark to bright)
pub fn magma_color_scale() -> impl Fn(f64) -> D3Color + Send + Sync {
    move |t: f64| {
        let t = t.clamp(0.0, 1.0);
        let colors = [
            D3Color::from_hex(0x000004), // Black
            D3Color::from_hex(0x1c1044), // Dark purple
            D3Color::from_hex(0x4f127b), // Purple
            D3Color::from_hex(0x812581), // Magenta-purple
            D3Color::from_hex(0xb5367a), // Magenta
            D3Color::from_hex(0xe55964), // Pink-red
            D3Color::from_hex(0xfb8761), // Orange
            D3Color::from_hex(0xfec287), // Light orange
            D3Color::from_hex(0xfcfdbf), // Light yellow
        ];

        let idx = (t * (colors.len() - 1) as f64) as usize;
        let idx = idx.min(colors.len() - 2);
        let local_t = (t * (colors.len() - 1) as f64) - idx as f64;

        colors[idx].interpolate(&colors[idx + 1], local_t as f32)
    }
}

/// Create a plasma color scale (perceptually uniform, purple to yellow)
pub fn plasma_color_scale() -> impl Fn(f64) -> D3Color + Send + Sync {
    move |t: f64| {
        let t = t.clamp(0.0, 1.0);
        let colors = [
            D3Color::from_hex(0x0d0887), // Dark blue
            D3Color::from_hex(0x46039f), // Purple
            D3Color::from_hex(0x7201a8), // Violet
            D3Color::from_hex(0x9c179e), // Magenta
            D3Color::from_hex(0xbd3786), // Pink
            D3Color::from_hex(0xd8576b), // Red-pink
            D3Color::from_hex(0xed7953), // Orange
            D3Color::from_hex(0xfb9f3a), // Yellow-orange
            D3Color::from_hex(0xfdca26), // Yellow
            D3Color::from_hex(0xf0f921), // Bright yellow
        ];

        let idx = (t * (colors.len() - 1) as f64) as usize;
        let idx = idx.min(colors.len() - 2);
        let local_t = (t * (colors.len() - 1) as f64) - idx as f64;

        colors[idx].interpolate(&colors[idx + 1], local_t as f32)
    }
}

/// Create an inferno color scale (perceptually uniform, black to yellow)
pub fn inferno_color_scale() -> impl Fn(f64) -> D3Color + Send + Sync {
    move |t: f64| {
        let t = t.clamp(0.0, 1.0);
        let colors = [
            D3Color::from_hex(0x000004), // Black
            D3Color::from_hex(0x1f0c48), // Dark purple
            D3Color::from_hex(0x550f6d), // Purple
            D3Color::from_hex(0x88226a), // Magenta
            D3Color::from_hex(0xba3655), // Red
            D3Color::from_hex(0xe35933), // Orange-red
            D3Color::from_hex(0xf98c09), // Orange
            D3Color::from_hex(0xf9c932), // Yellow-orange
            D3Color::from_hex(0xfcffa4), // Light yellow
        ];

        let idx = (t * (colors.len() - 1) as f64) as usize;
        let idx = idx.min(colors.len() - 2);
        let local_t = (t * (colors.len() - 1) as f64) - idx as f64;

        colors[idx].interpolate(&colors[idx + 1], local_t as f32)
    }
}

// ============================================================================
// Contour Band Element (for filled contours between threshold levels)
// ============================================================================

use crate::contour::ContourBand;

/// A custom element for rendering filled contour bands
pub struct ContourBandElement<XS, YS> {
    /// The contour bands to render
    bands: Arc<[ContourBand]>,
    /// X scale
    x_scale: XS,
    /// Y scale
    y_scale: YS,
    /// Configuration
    config: ContourConfig,
    /// Value range for color normalization
    value_range: (f64, f64),
    /// Element height
    height: Pixels,
}

impl<XS, YS> ContourBandElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone,
    YS: Scale<f64, f64> + Clone,
{
    /// Create a new contour band element
    pub fn new(bands: impl Into<Arc<[ContourBand]>>, x_scale: XS, y_scale: YS) -> Self {
        let bands = bands.into();

        // Calculate value range from bands
        let value_range = if bands.is_empty() {
            (0.0, 1.0)
        } else {
            let min = bands.iter().map(|b| b.lower).fold(f64::INFINITY, f64::min);
            let max = bands
                .iter()
                .map(|b| b.upper)
                .fold(f64::NEG_INFINITY, f64::max);
            (min, max)
        };

        Self {
            bands,
            x_scale,
            y_scale,
            config: ContourConfig::default(),
            value_range,
            height: px(400.0),
        }
    }

    /// Set the configuration
    pub fn config(mut self, config: ContourConfig) -> Self {
        self.config = config;
        self
    }

    /// Set the value range for color normalization
    pub fn value_range(mut self, min: f64, max: f64) -> Self {
        self.value_range = (min, max);
        self
    }

    /// Set the element height
    pub fn height(mut self, height: Pixels) -> Self {
        self.height = height;
        self
    }

    /// Normalize a value to 0.0-1.0 range
    fn normalize_value(&self, value: f64) -> f64 {
        let (min, max) = self.value_range;
        if (max - min).abs() < 1e-10 {
            0.5
        } else {
            (value - min) / (max - min)
        }
    }

    /// Get fill color for a band's mid value
    fn get_fill_color(&self, mid_value: f64) -> D3Color {
        let t = self.normalize_value(mid_value);
        if let Some(ref scale) = self.config.color_scale {
            scale(t)
        } else {
            self.config.fill_color
        }
    }
}

impl<XS, YS> IntoElement for ContourBandElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone + 'static,
    YS: Scale<f64, f64> + Clone + 'static,
{
    type Element = Self;

    fn into_element(self) -> Self::Element {
        self
    }
}

impl<XS, YS> Element for ContourBandElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone + 'static,
    YS: Scale<f64, f64> + Clone + 'static,
{
    type RequestLayoutState = ();
    type PrepaintState = ();

    fn id(&self) -> Option<ElementId> {
        None
    }

    fn source_location(&self) -> Option<&'static panic::Location<'static>> {
        None
    }

    fn request_layout(
        &mut self,
        _id: Option<&GlobalElementId>,
        _inspector_id: Option<&InspectorElementId>,
        window: &mut Window,
        cx: &mut App,
    ) -> (LayoutId, Self::RequestLayoutState) {
        // Use the scale's range for width to ensure alignment with other chart elements
        let (x_range_min, x_range_max) = self.x_scale.range();
        let computed_width = px((x_range_max - x_range_min).abs() as f32);

        let layout_id = window.request_layout(
            Style {
                size: size(computed_width.into(), self.height.into()),
                min_size: size(px(100.0).into(), px(100.0).into()),
                ..Default::default()
            },
            [],
            cx,
        );
        (layout_id, ())
    }

    fn prepaint(
        &mut self,
        _id: Option<&GlobalElementId>,
        _inspector_id: Option<&InspectorElementId>,
        _bounds: Bounds<Pixels>,
        _request_layout: &mut Self::RequestLayoutState,
        _window: &mut Window,
        _cx: &mut App,
    ) -> Self::PrepaintState {
    }

    fn paint(
        &mut self,
        _id: Option<&GlobalElementId>,
        _inspector_id: Option<&InspectorElementId>,
        bounds: Bounds<Pixels>,
        _request_layout: &mut Self::RequestLayoutState,
        _prepaint: &mut Self::PrepaintState,
        window: &mut Window,
        _cx: &mut App,
    ) {
        let origin_x: f32 = bounds.origin.x.into();
        let origin_y: f32 = bounds.origin.y.into();
        let width: f32 = bounds.size.width.into();
        let height: f32 = bounds.size.height.into();

        // Get the range (screen coordinates) for proper normalization
        let (x_range_min, x_range_max) = self.x_scale.range();
        let (y_range_min, y_range_max) = self.y_scale.range();
        let x_range_span = (x_range_max - x_range_min).abs();
        let y_range_span = (y_range_max - y_range_min).abs();
        // Use actual min/max for proper handling of inverted scales
        let x_range_lo = x_range_min.min(x_range_max);
        let y_range_lo = y_range_min.min(y_range_max);

        // Paint each band (from lowest to highest value for proper layering)
        for band in self.bands.iter() {
            let fill_color = self.get_fill_color(band.mid_value());

            for ring in &band.polygons {
                if ring.points.len() < 3 {
                    continue;
                }

                // Convert ring points to screen coordinates using the scale
                let screen_points: Vec<Point<Pixels>> = ring
                    .points
                    .iter()
                    .map(|p| {
                        // Use scale.scale() to transform data coordinates to range coordinates
                        let x_scaled = self.x_scale.scale(p.x);
                        let y_scaled = self.y_scale.scale(p.y);

                        // Normalize to 0-1 based on range
                        // Y scale is already inverted (high values at top=0, low at bottom=height)
                        // so no additional inversion needed here
                        let x_norm = ((x_scaled - x_range_lo) / x_range_span) as f32;
                        let y_norm = ((y_scaled - y_range_lo) / y_range_span) as f32;

                        let screen_x = origin_x + x_norm * width;
                        let screen_y = origin_y + y_norm * height;
                        point(px(screen_x), px(screen_y))
                    })
                    .collect();

                // Paint fill using PathBuilder
                if screen_points.len() >= 3 {
                    let mut fill_rgba = fill_color.to_rgba();
                    fill_rgba.a *= self.config.fill_opacity;

                    // Draw fill
                    let mut builder = PathBuilder::fill();
                    builder.move_to(screen_points[0]);
                    for pt in &screen_points[1..] {
                        builder.line_to(*pt);
                    }

                    if let Ok(path) = builder.build() {
                        window.paint_path(path, fill_rgba);
                    }

                    // Draw a stroke with the same color to eliminate anti-aliasing gaps
                    // between adjacent bands. Use 2px stroke for better coverage.
                    let stroke_color = fill_rgba;
                    let mut stroke_builder = PathBuilder::stroke(px(2.0));
                    stroke_builder.move_to(screen_points[0]);
                    for pt in &screen_points[1..] {
                        stroke_builder.line_to(*pt);
                    }
                    stroke_builder.line_to(screen_points[0]); // Close the path

                    if let Ok(stroke_path) = stroke_builder.build() {
                        window.paint_path(stroke_path, stroke_color);
                    }
                }
            }
        }
    }
}

/// Render filled contour bands using scales
pub fn render_contour_bands<XS, YS>(
    bands: impl Into<Arc<[ContourBand]>>,
    x_scale: &XS,
    y_scale: &YS,
    config: &ContourConfig,
) -> ContourBandElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone,
    YS: Scale<f64, f64> + Clone,
{
    ContourBandElement::new(bands, x_scale.clone(), y_scale.clone()).config(config.clone())
}

// ============================================================================
// Heatmap Element (for gap-free surface rendering using quads)
// ============================================================================

/// Data for a heatmap (2D grid of values)
#[derive(Clone)]
pub struct HeatmapData {
    /// X coordinates (column positions)
    pub x_values: Vec<f64>,
    /// Y coordinates (row positions)
    pub y_values: Vec<f64>,
    /// Values in row-major order: values[y * width + x]
    pub values: Vec<f64>,
    /// Number of columns
    pub width: usize,
    /// Number of rows
    pub height: usize,
}

impl HeatmapData {
    /// Create heatmap data from a 2D grid
    pub fn new(x_values: Vec<f64>, y_values: Vec<f64>, values: Vec<f64>) -> Self {
        let width = x_values.len();
        let height = y_values.len();
        Self {
            x_values,
            y_values,
            values,
            width,
            height,
        }
    }

    /// Get value at grid position
    pub fn get(&self, x: usize, y: usize) -> Option<f64> {
        if x < self.width && y < self.height {
            Some(self.values[y * self.width + x])
        } else {
            None
        }
    }
}

/// A custom element for rendering heatmaps as colored quads
/// This eliminates anti-aliasing gaps between cells
pub struct HeatmapElement<XS, YS> {
    /// The heatmap data
    data: HeatmapData,
    /// X scale
    x_scale: XS,
    /// Y scale
    y_scale: YS,
    /// Configuration
    config: ContourConfig,
    /// Value range for color normalization
    value_range: (f64, f64),
    /// Element height
    height: Pixels,
}

impl<XS, YS> HeatmapElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone,
    YS: Scale<f64, f64> + Clone,
{
    /// Create a new heatmap element
    pub fn new(data: HeatmapData, x_scale: XS, y_scale: YS) -> Self {
        // Calculate value range from data
        let value_range = if data.values.is_empty() {
            (0.0, 1.0)
        } else {
            let min = data.values.iter().cloned().fold(f64::INFINITY, f64::min);
            let max = data
                .values
                .iter()
                .cloned()
                .fold(f64::NEG_INFINITY, f64::max);
            (min, max)
        };

        Self {
            data,
            x_scale,
            y_scale,
            config: ContourConfig::default(),
            value_range,
            height: px(400.0),
        }
    }

    /// Set the configuration
    pub fn config(mut self, config: ContourConfig) -> Self {
        self.config = config;
        self
    }

    /// Set the value range for color normalization
    pub fn value_range(mut self, min: f64, max: f64) -> Self {
        self.value_range = (min, max);
        self
    }

    /// Set the element height
    pub fn height(mut self, height: Pixels) -> Self {
        self.height = height;
        self
    }

    /// Normalize a value to 0.0-1.0 range
    fn normalize_value(&self, value: f64) -> f64 {
        let (min, max) = self.value_range;
        if (max - min).abs() < 1e-10 {
            0.5
        } else {
            (value - min) / (max - min)
        }
    }

    /// Get fill color for a value
    fn get_fill_color(&self, value: f64) -> D3Color {
        let t = self.normalize_value(value);
        if let Some(ref scale) = self.config.color_scale {
            scale(t)
        } else {
            self.config.fill_color
        }
    }
}

impl<XS, YS> IntoElement for HeatmapElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone + 'static,
    YS: Scale<f64, f64> + Clone + 'static,
{
    type Element = Self;

    fn into_element(self) -> Self::Element {
        self
    }
}

impl<XS, YS> Element for HeatmapElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone + 'static,
    YS: Scale<f64, f64> + Clone + 'static,
{
    type RequestLayoutState = ();
    type PrepaintState = ();

    fn id(&self) -> Option<ElementId> {
        None
    }

    fn source_location(&self) -> Option<&'static panic::Location<'static>> {
        None
    }

    fn request_layout(
        &mut self,
        _id: Option<&GlobalElementId>,
        _inspector_id: Option<&InspectorElementId>,
        window: &mut Window,
        cx: &mut App,
    ) -> (LayoutId, Self::RequestLayoutState) {
        // Use the scale's range for width to ensure alignment with other chart elements
        let (x_range_min, x_range_max) = self.x_scale.range();
        let computed_width = px((x_range_max - x_range_min).abs() as f32);

        let layout_id = window.request_layout(
            Style {
                size: size(computed_width.into(), self.height.into()),
                min_size: size(px(100.0).into(), px(100.0).into()),
                ..Default::default()
            },
            [],
            cx,
        );
        (layout_id, ())
    }

    fn prepaint(
        &mut self,
        _id: Option<&GlobalElementId>,
        _inspector_id: Option<&InspectorElementId>,
        _bounds: Bounds<Pixels>,
        _request_layout: &mut Self::RequestLayoutState,
        _window: &mut Window,
        _cx: &mut App,
    ) -> Self::PrepaintState {
    }

    fn paint(
        &mut self,
        _id: Option<&GlobalElementId>,
        _inspector_id: Option<&InspectorElementId>,
        bounds: Bounds<Pixels>,
        _request_layout: &mut Self::RequestLayoutState,
        _prepaint: &mut Self::PrepaintState,
        window: &mut Window,
        _cx: &mut App,
    ) {
        let origin_x: f32 = bounds.origin.x.into();
        let origin_y: f32 = bounds.origin.y.into();
        let width: f32 = bounds.size.width.into();
        let height: f32 = bounds.size.height.into();

        // Get the range (screen coordinates) for proper normalization
        let (x_range_min, x_range_max) = self.x_scale.range();
        let (y_range_min, y_range_max) = self.y_scale.range();
        let x_range_span = (x_range_max - x_range_min).abs();
        let y_range_span = (y_range_max - y_range_min).abs();

        // Paint each cell as a quad (rectangle)
        for yi in 0..self.data.height {
            for xi in 0..self.data.width {
                let value = match self.data.get(xi, yi) {
                    Some(v) if v.is_finite() => v,
                    _ => continue,
                };

                // Get cell boundaries in data coordinates
                let x0_data = self.data.x_values[xi];
                let x1_data = if xi + 1 < self.data.width {
                    self.data.x_values[xi + 1]
                } else {
                    // Extrapolate for last column
                    if xi > 0 {
                        x0_data + (x0_data - self.data.x_values[xi - 1])
                    } else {
                        x0_data * 1.1
                    }
                };

                let y0_data = self.data.y_values[yi];
                let y1_data = if yi + 1 < self.data.height {
                    self.data.y_values[yi + 1]
                } else {
                    // Extrapolate for last row
                    if yi > 0 {
                        y0_data + (y0_data - self.data.y_values[yi - 1])
                    } else {
                        y0_data * 1.1
                    }
                };

                // Transform to screen coordinates using the scale
                let x0_scaled = self.x_scale.scale(x0_data);
                let x1_scaled = self.x_scale.scale(x1_data);
                let y0_scaled = self.y_scale.scale(y0_data);
                let y1_scaled = self.y_scale.scale(y1_data);

                // Normalize to 0-1 based on range
                // Use actual min/max for proper handling of inverted scales
                let x_range_lo = x_range_min.min(x_range_max);
                let y_range_lo = y_range_min.min(y_range_max);

                let x0_norm = ((x0_scaled - x_range_lo) / x_range_span) as f32;
                let x1_norm = ((x1_scaled - x_range_lo) / x_range_span) as f32;
                // Y scale is already inverted (high values at top=0, low at bottom=height)
                // so no additional inversion needed here
                let y0_norm = ((y0_scaled - y_range_lo) / y_range_span) as f32;
                let y1_norm = ((y1_scaled - y_range_lo) / y_range_span) as f32;

                // Convert to screen pixels
                let screen_x0 = origin_x + x0_norm.min(x1_norm) * width;
                let screen_x1 = origin_x + x0_norm.max(x1_norm) * width;
                let screen_y0 = origin_y + y0_norm.min(y1_norm) * height;
                let screen_y1 = origin_y + y0_norm.max(y1_norm) * height;

                // Ensure minimum cell size of 1 pixel and slight overlap to prevent gaps
                let cell_width = (screen_x1 - screen_x0).max(1.0) + 0.5;
                let cell_height = (screen_y1 - screen_y0).max(1.0) + 0.5;

                // Get color for this cell
                let fill_color = self.get_fill_color(value);
                let mut fill_rgba = fill_color.to_rgba();
                fill_rgba.a *= self.config.fill_opacity;

                // Paint as a quad (rectangle) - no anti-aliasing gaps!
                let cell_bounds = Bounds::new(
                    point(px(screen_x0), px(screen_y0)),
                    size(px(cell_width), px(cell_height)),
                );

                window.paint_quad(PaintQuad {
                    bounds: cell_bounds,
                    corner_radii: Corners::default(),
                    background: fill_rgba.into(),
                    border_widths: Edges::default(),
                    border_color: gpui::transparent_black(),
                    border_style: Default::default(),
                });
            }
        }
    }
}

/// Render a heatmap (2D grid of colored cells) using scales
pub fn render_heatmap<XS, YS>(
    data: HeatmapData,
    x_scale: &XS,
    y_scale: &YS,
    config: &ContourConfig,
) -> HeatmapElement<XS, YS>
where
    XS: Scale<f64, f64> + Clone,
    YS: Scale<f64, f64> + Clone,
{
    HeatmapElement::new(data, x_scale.clone(), y_scale.clone()).config(config.clone())
}
